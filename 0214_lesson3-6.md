# SQL 응용
- 1974년 IBM연구소에서 개발한 SEQUEL에서 유래함
- 관계대수와 관계해석을 기초로 한 혼합 데이터 언어

## 1. SQL의 분류
#### DDL
- Domain(도메인),schema(스키마),Table(테이블),view(뷰), index(인덱스)를 정의하거나 변경 또는 삭제할 때 사용하는 언어

|명령어|기능|
|:---:|---|
|CREATE|DOMAIN, SCHEMA, TABLE, VIEW, INDEX 정의|
|ALTER|TABLE에 대한 정의 변경|
|DROP|DOMAIN, SCHEMA, TABLE, VIEW, INDEX 삭제 / CASCADE: 참조하는 모든 개체 함께 제거 / RESTRICTED: 다른 개체가 제거할 요소를 참조 중이면 제거 취소|
#### DML
- 데잍어베이스 사용자가 응용 프로그램이나 질의어를 통해 저장된 데이터를 실질적으로 처리하는 데 사용하는 언어

|명령어|기능|
|:----:|----|
|SELECT|테이블에서 조건에 맞는 행 검색|
|INSERT|테이블에 새로운 행 삽입|
|DELETE|테이블에서 조건에 맞는 행 삭제|
|UPDATE|테이블에서 조건에 맞는 행의 내용 갱신|

#### DCL
- 데이터의 무결성, 보안, 회복, 병행수쟁 제어 등을 정의하는데 사용되는 언어
- 데이터베이스 관리자가 데이터 관리를 목적으로 사용

|명령어|기능|
|:----:|----|
|COMMIT|명령에 의해 수행된 결과를 실제 물리적 디스크로 저장하고, 데이터베이스 조작 작업이 정상적으로 완료 됐음을 알려주는 명령어|
|ROLLBACK|아직 COMMIT되지 않은 변경된 모든 내용들을 취소하고, 데이터베이스를 이전 상태로 되돌리는 명령어 / SAVEPOINT : 트랜잭션 내에 ROLLBACK 할 위치인 저장점을 지정하는 명령어|
|GRANT|데이터베이스 사용자에게 사용권한 부여 -> GRANT (권한 리스트) ON (개체) TO(사용자)[WITH GRANT OPTION] / WITH GRANT OPTION: 부여받은 권한을 다른 사용자에게 다시 부여할 수 있는 권한|
|REVOKE|데이터베이스 사용자의 사용권한 취소 -> REVOKE [GRANT OPTION FOR](권한 리스트) ON (개체)FROM(사용자)[CASCADE]; / GRANT OPTION FOR : 다른 사용자에게 권한을 부여할 수 있는 권한을 취소|

## 2. SELECT
- WHERE 절 : 검색할 조건을 기술
- ORDER BY 절 : 특정 속성을 기준으로 정렬해 검색할 때 사용
- GROUP BY 절 : 특정 속성을 기준으로 그룹화해 검색할 때 사용, 일반적으로 그룹 함수와 함께 사용
- HAVING 절 : GROUP BY 와 함께 사용 되며, 그룹에 대한 조건 지정 (DISTINCT : 중복방지)
- 집계/그룹함수 : GROUP BY절에 지정된 그룹별로 열의 값을 집계할 함수를 기술함

|종류|설명|
|---|---|
|COUNT|그룹별 행 수를 구하는 함수|
|SUM|그룹별 합계를 구하는 함수|
|AVG|그룹별 평균을 구하는 함수|
|MAX|그룹별 최대값을 구하는 함수|
|MIN|그룹별 최소값을 구하는 함수|
|STDDEV|그룹별 표준편차를 구하는함수|
|VARIANCE|그룹별 분산을 구하는 함수|
|ROLLUP|인수로 주어진 열을 대상으로 그룹별 소계를 구하는 함수, 열의 개수가 n개면 , n+1레벨까지, 하위레벨에서 상위 레벨 순으로 데이터 집계|
|CUBE|인수로 주어진 열을 대상으로 모든 조합의 그룹별 소계를 구하는 함수, 열의 개수가 n개면 n2레벨까지, 상위레벨에서 하위레벨 순으로 데이터 집계|

- 윈도우 함수 : GROUP BY 절을 이용하지 않고 열의 값을 집계할 함수를 기술함
> - 함수의 인수로 지정한 열이 대상 레코드의 범위가 되는데, 이를 WINDOW라 함
> - PARTITION BY : 윈도우 함수가 적용될 범위로 사용할 열 지정
> - WINDOW (함수) OVER (PARTITION BY 열 ORDER BY 열)

|종류|설명|
|---|---|
|ROW NUMBER()|WINDOW별로 각 레코드에 대한 일련 번호를 반환함|
|RANK()|WINDOW별로 순위를 반환하며, 공동 순위를 반영함 (ex 1,1,1,4,5)|
|DENSE_RANK()|WINDOW별로 순위를 반환하며, 공동 순위를 무시하고 순위를 부여함(ex 1,1,1,2,3)|

## 3. 조인(JOIN)
- 결합을 의미하며, 관계형 데이터베이스에서의 조인은 교집합결과를 가지는 결합 방법을 의미
- 두 테이블로부터 연관된 행들을 결합해 , 하나의 새로운 테이블을 반환

- 논리적 조인

|구분|조인유형|설명|
|:---:|---|---|
|INNER JOIN|EQUI JOIN(동등조인)|공통 존재 컬럼의 값이 같은 경우를 추출|
||NATURAL JOIN(자연조인)|두 테이블의 모든 컬럼을 비교해, 같은 컬럼 명을 가진 값이 같은 경우를 추출|
||CROSS JOIN(교차 조인)|조인 조건이 없는 모든 데이터 조합을 추출|
|OUTER JOIN|LEFT OUTER JOIN|왼쪽 테이블의 모든 데이터와 오른쪽 테이블의 동일 데이터를 추출|
||RIGHT OUTER JOIN|오른쪽 테이블의 모든 데이터와 왼족 테이블의 동일 데이터를 추출|
||FULL OUTER JOIN|양쪽의 모든 데이터를 추출|

- 물리적 조인

|종류|설명|
|:---:|---|
|NESTED-LOOP JOIN|2개 이상의 테이블에서 하나의 집합을 기준으로 순차적으로 상대방 ROW를 결합해 원하는 결과를 조합하는 방식|
|SORT-MERGE JOIN|양쪽 테이블의 정렬한 결과를 차례로 검색하면서 연결고리 형태로 합병하는 방식|
|HASH JOIN|해싱 함수 기법을 활용하여 조인을 수행하는 방식|


---
# SQL 활용
## 1. 절차형 SQL
- C, JAVA등의 프로그래밍 언어와 같이 연속적인 실행이나 분기, 반복 등의 제어가 가능한 SQL
- 일반적인 프로그래밍 언어에 비해 효율이 떨어지지만, 연속적인 작업 처리 적합
- BEGIN ~ END 형식으로 작성되는 블록 구조로 기능별 모듈화 가능

## 2. 프로시저
- 호출을 통해 실행되어 미리 저장해 놓은 SQL작업 수행, 처리 결과는 한 개 이상의 값 혹은 반환을 아예 하지 않음
- 시스템의 일일 마감 작업, 일관 작업 등에 주로 사용됨

> DECLARE(필수) : 프로시저의 명칭, 변수, 인수 데이터 타입을 정의하는 선언부
<br>
> BEGIN(필수) : 프로시저의 시작을 의미, 실행부
<br>
> CONTROL : 조건문 또는 반복문이 삽입되어 순차적으로 처리됨
<br>
> SQL : DML, DCL이 삽입되어 데이터 관리를 위한 작업 수행
<br>
> EXCEPTION : BEGIN ~ END 안의 구문 실행 시 예외가 발생하면 이를 처리
<br>
> TRANSACTION : 수행된 데이터 작업들을 DB에 적용할지 말지 결정하는 처리부
<br>
> END(필수) : 프로시저의 종료를 의미, BEGIN/END는 함께 다님

## 3. 트리거
- 삽입, 갱신, 삭제 등의 이벤트가 발생할 때마다 관련 작업을 자동 수행
- 데이터베이스에 저장되며, 데이터 변경 및 무결성 유지, 로그 메시지 출력 등의 목적으로 사용됨
- DCL을 사용할 수 없으며, DCL이 포함된 프로시저나 함수를 호출하는 경우에도 오류 발생
- 트리거에 오류가 있는 경우 트리거가 처리하는 데이터에도 영향을 미치므로 트리거를 생성할 때 세삼한 주의가 필요

> DECLARE(필수) : 트리거의 명칭, 변수 및 상수, 데이터 타입을 정의하는 선언부
<br>
> EVENT(필수) : 트리거가 실행되는 조건을 명시
<br>
> BEGIN(필수) : 트리거의 시작을 의미 , 실행부
<br>
> CONTROL : 조건문 또는 반복문이 삽입되어 순차적으로 처리됨
<br>
> SQL : DML문이 삽입되어 데이터 관리를 위한 작업 수행
<br>
> EXCEPTION : BEGIN ~ END안의 구문 실행시 예외가 발생하면 이를 처리
<br>
> END(필수) : 트리거의 종료를 의미, BEGIN/END는 함께 다님

## 3. 사용자 정의 함수
- 프로시저와 유사하게 SQL을 사용해 일련의 작업을 연속적으로 처리
- 종료 시 예약어 RETURN을 사용해 처리 결과를 단일값으로 반환
- DML문(SELECT, INSERT, DELETE, UPDATE)의 호출에 의해 실행됨
- RETURN을 통해 값을 반환해 , 출력 파라미터가 없음
- INSERT, DELETE, UPDATE로 테이블 조작은 할 수 없고, SELECT로 조회만 할 수 있음
- 프로시저를 호출해 사용할 수 없음

|구분|프로시저|사용자정의함수|
|:---:|---|---|
|반환값|없거나 1개 이상 가능|1개(단일값)|
|파라미터|입,출력 가능(IN,OUT)|입력만 가능|
|사용 가능 명령문|DML,DCL|SELECT|
|호출|프로시저, 사용자 정의함수|사용자 정의 함수|
|사용 방법|실행문|DML에 포함해서 사용|

> DECLARE(필수) : 사용자 정의 함수의 명칭, 변수 ,인수 ,데이터 타입을 정의하는 선언부
<br>
> BEGIN (필수) : 사용자 정의 함수의 시작을 의미, 실행부
<br>
> CONTROL : 조건문 또는 반복문이 삽입되어 순차적으로 처리됨
<br>
> SQL : SELECT문의 삽입되어 데이터 관리를 위한 작업 수행
<br>
> EXCEPTION : BEGIN ~ END 안의 구문 실행 시 예외가 발생하면 이를 처리
<br>
> RETURN(필수) : 호출 프로그램에 반활할 값이나 변수를 정의
<br>
> END(필수) : 사용자 정의 함수의 종료를 의미, BEGIN/END는 함꼐 다님

---
# DBMS 접속 기술
## 1. 웹 응용 세스템의 구조
- 사용자 <-> 웹 서버 <-> WAS <-> DBMS
- 사용자는 웹서버에 접속해 데이터를 주고 받고, 웹 서버는 WAS에게 해당 요청을 전달함, 그 다음 WAS는 수신한 요청을 트랜잭션 언어로 변환한 후 DBMS에 전달해 데이터를 받으면, 이 데이터를 다시 웹서버로 전달해 사용자에게 도달하게 함

## 2. DBMS 접속 기술
- JDBC 
> - 1997년 썬 마이크로시스템에서 출시 ,JAVA언어로 다양한 종류의 데이터베이스에 접속하고 SQL문을 수행할 때 사용되는 표준 API
> - 접속하려는 DBMS에 대한 드라이버가 필요

- ODBC
> - 1992년 마이크로소프트에서 출시 ,데이터베이스에 접근하기 위한 표준 개방형 API로 개발 언어에 관계없이 사용 가능
- ODBC도 접속하려는 DBMS에 맞는 드라이버가 필요하지만, 접속하려는 DBMS의 인터페이스를 알지 못하더라도 ODBC문장을 사용해 SQL을 작성하면 ODBC에 포함된 드라이버 관리자가 해당 DBMS의 인터페이스에 맞게 연결해줌
(DBMS의 종류를 몰라도 됨)

## 3. 정적 SQL vs 동적 SQL
||정적 SQL|동적SQL|
|:---:|---|---|
|SQL구성|커서(Cursor)를 통한 정적 처리|문자열 변수에 담아 동적 처리|
|개발패턴|커서의 범위 안에서 반복문을 활용해 SQL작성|NVL 함수를 사용할 필요 없이 로직을 통해 SQL작성|
|실행 속도|빠름|느림|
|사전 검사|가능|불가능->SQL변형위험|

--- 
# ORM(Object-Relational Mapping)
## 1. ORM의 개요
- 객체와 관계형데이터베이스의 데이터를 연결하는 기술
- ORM으로 생성된 가상의 객체지향 데이터베이스는 프로그래밍 코드 또는 데이터베이스와 독립적이므로 재사용 및 유지보수 용이
- 직관적이고 간단하게 데이터 조작 가능

## 2. ORM 프레임워크

|언어|프레임워크|
|:---:|---|
|JAVA|JPA,Hibernate, Eclipse Link, Data Nucleus, Ebean등|
|C++|ODB,QxOrm등|
|Python|Django, SQL Alchemy, Storm 등|
|IOS|Core Date, Database Objects 등|
|.NET|NHibernate, Database Objects, Datter등|
|PHP|Doctrine, Propel,RedBean등|

## 3. ORM의 한계
- 프레임워크가 자동으로 SQL을 작성하기 때문에 의도대로 작성되었는지 확인해야함
- 객체지향적인 사용 고려와 프로젝트가 크고 복잡해질수록 적용하기 어려워짐
- 기존의 기업들은 ORM을 고려하지 않은 데이터베이스를 사용하고 있기 때문에 , ORM에 적합하게 변환하려면 많은 시간과 노력 필요

---
# 쿼리 성능 최적화
- 데이터 입, 출력 애플리케이션의 성능 향상을 위해 SQL 코드를 최적화 하는것
- 쿼리 성능 최적화하기 전, 성능 측정 도구인 APM을 사용해 최적화 할 쿼리를 선정해야함
- 최적화 할 쿼리에 대해 옵티마이저가 수립한 실행 계획을 EXPLAIN 명령어를 통해 검토하고 , SQL코드와 인덱스 재구성
(옵티마이저 : 작성된 SQL이 가장 효율적으로 수행되도록 최적의 경로를 찾아 주는 모듈)

## 1. RBO(Rule Based Optimizer) vs CBO(Cost Based Optimizer)
||RBO|CBO|
|:---:|---|---|
|최적화 기준|규칙에 정의된 우선 순위|액세스 비용|
|성능 기준| 개발자의 SQL 숙련도|옵티마이저 알고리즘의 예측 성능|
|특징|실행 계획 예측이 쉬움|성능 통계치 정보 활용, 예측이 복잡함|
|고려사항|개발자의 규칙 이해도, 구칙의 효율성|비용산출 공식의 정확성|


## 2. SQL코드 및 인덱스 재구성
- SQL 코드 재구성
> - 서브 쿼리에 특정 데이터가 존재하는지 확인 할 떄는 IN보다 EXISTS활용
> - 실행 계획이 잘못되었다고 판단되는 경우 힌트를 활용해 변경

- 인덱스 재구성
> - 인덱스의 추가 및 변경은 해당 테이블을 참조하는 다른 SQL문에도 영향을 줄 수 있으므로 신중히 결정
> - 단일 인덱스로 쓰기나 수정 없이 읽기로만 사용되는 테이블의 경우 IOT(index-orgaized Table)구성 고려

---
# 데이터 전환
## 1. 데이터 전환의 정의
- 운영중인 기존 정보시스템에 축적되어 있는 데이터를 추출하여 새로 개발할 정보 시스템에서 운영 가능하도록 변환 후, 적재 하는 일련의 과정
- ETL(Extraction, Transformation, Loading): 추출, 변환, 적재 과정
- 데이터 이행, 데이터 이관이라고도 함

## 2. 데이터 전환 계획서
|항목|세부항목|
|:---:|---|
|데이터 전환 개요|데이터전환 목표 / 주요 성공 요인 / 전제조건 및 제약 조건|
|데이터 전환 대상 및 범위||
|데이터 전환 환경 구성|원천시스템 구성도(As-is시스템) / 목적 시스템 구성도(To-Be 시스템) / 전환 단계별 DISK 사용량|
|데이터 전환 조직 및 역할|데이터 전환 조직도 / 조직별 역할|
|데이터 전환 일정||
|데이터 전환 방안|데이터 전환 규칙 / 데이터 전환 절차 / 데이터 전환 방법 / 데이터 전환 설계 / 전환 프로그램 개발 및 테스트 계획 / 데이터 전환 계획 / 데이터 검증 방안|
|데이터 정비 방안|데이터 정비 대상 및 방법 / 데이터 정비 일정 및 조직|
|비상 계획|종합상황실 및 의사소통 체계|
|데이터 목구 대책||

# 라이브러리
## 1. 라이브러리의 개념
- 프로그램을 효율적으로 개발할 수 있도록 자주 사용하는 함수나 데이터들을 미리 만들어 모아 놓은 집합체로 필요할 때 언제든지 호출하여 사용할 수 있음

#### 표준 라이브러리
- 프로그래밍언어에 기본적으로 포함되어 있는 라이브러리
#### 외부 라이브러리
- 개발자들이 필요한 기능을 만들어 인터넷 등에 공유해 놓을 것으로, 다운받아 설치한 후 사용함

## 2. C언어의 대표적인 표준 라이브러리
|헤더파일|기능|
|:---:|---|
|stdio.h|데이터의 입,출력에 사용되는 기능 제공|
|math.h|수학 함수 제공|
|string.h|문자열 처리에 사용되는 기능 제공|
|stdlib.h|자료형 변환, 난수발생, 메모리할당에 사용되는 기능들 제공|
|time.h|시간 처리에 사용되는 기능 제공|

## 3. JAVA의 대표적인 표준 라이브러리
- JAVA에서 패키지를 사용하려면 'import java.util'과 같이 import문을 이용해 선언한 후 사용해야 함

|패키지|기능|
|:---:|---|
|java.lang|자바에 기본적으로 필요한 인터페이스, 자료형,예외 처리 등에 관련된 기능 제공, import문 없이도 사용 가능|
|java.util|날짜처리, 난수발생, 복잡한 문자열 처리 등에 관련된 기능 제공|
|java.io|파일 입,출력과 관련된 기능 및 프로토콜 제공|
|java.net|네트워크와 관련된 기능 제공|
|java.awt|사용자 인터페이스와 관련된 기능 제공|

---
# 데이터 입,출력
## 1. scanf()함수
- C언어의 표준 입력 함수, 키보드로 입력받아 변수에 저장하는 함수
![image](https://user-images.githubusercontent.com/65350890/108622074-c894ec80-7479-11eb-9323-0a08a9106c07.png)

#### 서식문자열
![image](https://user-images.githubusercontent.com/65350890/108622088-db0f2600-7479-11eb-869d-e41e9b042194.png)

## 2. printf()함수
- C언어의 표준 출력 함수, 인수로 주어진 값을 화면에 출력하는 함수
![image](https://user-images.githubusercontent.com/65350890/108622119-0bef5b00-747a-11eb-99f1-b2253759b139.png)

#### 주요 제어 문자
![image](https://user-images.githubusercontent.com/65350890/108622127-19a4e080-747a-11eb-8aba-05c579f47144.png)

## 3. 기타 표준 입,출력 함수
![image](https://user-images.githubusercontent.com/65350890/108622151-2cb7b080-747a-11eb-88ef-cfa5aee928cf.png)

---
# 운영체제의 개념

## 1. 운영체제의 정의
- 컴퓨터 시스템의 자원들을 효율적으로 관리하며, 사용자가 컴퓨터를 편리하고 효과적으로사용할 수 있도록 환경을 제공하는 여러 프로그램의 모임
## 2. 운영체제의 목적
|목적|설명|
|:---:|---|
|처리능력|일정 시간 내에 시스템이 처리하는 일의 양|
|반환시간|시스템에 작업을 의뢰한 시간부터 처리가 완료될 때까지 걸린 시간|
|사용 가능도| 시스템을 사용할 필요가 있을 때 즉시 사용가능한 정도|
|신뢰도|시스템이 주어진 문제를 정확하게 해결하는 정도|

## 3. 운영체제의 기능 ★
- CPU, 메모리 공간, 프로세서,기억장치(주기억장치, 보조 기억장치), 입 출력 장치, 파일 및 정보 등의 자원 관리
- 다중 사용자와 다중 응용프로그램 환경 하에서 현재 상태를 파악하고 자원을 효율적으로 분배 및 관리하기 위해 스케줄링 기능 제공
- 사용자와 시스템 간의 편리한 인터페이스 제공, 입출력 장치와 사용자 프로그램 제어
- 데이터를 관리하고, 데이터 및 자원의 공유 기능을 제공
- 시스템의 오류 검사 및 복구, 자원 보호기능 제공
- 입,출력에 대한 보조기능 제공 -> 가상 계산기 기능 제공

## 4. 운영체제의 주요 자원관리
|자원|기능|
|:---:|---|
|프로세스 관리|프로세스 스케줄링 및 동기화 관리 담당|
|기억장치 관리|프로세스에게 메모리 할당 및 회수 관리 담당|
|주변장치 관리|입,출력장치 스케줄링 및 전반적인 관리 담당|
|파일 관리|파일의 생성과 삭제,변경,유지 등의 관리담당|

## 5. 운영체제의 종류
|운영체제|특징|인터페이스|
|:---:|---|---|
|windows|Microsoft사가 개발|GUI|
|UNIX|AT&T벨 연구소 , MIT, Generic Electric이 공동개발|CLI|
|LINUX|리누스 토발즈가 개발, UNIC와 호환이 가능한 커널, 누구나 제한없이 활용 및 재배포 가능한 오픈 소스|CLI|
|MACOS|Apple 사가 UNIX를 기반으로 개발|GUI|
|MS-DOS|Windows이전에 사용되던 운영체제|CLI|

## 6. widosws의 주요 특징 ★
#### GUI
- 키보드로 명령어를 직접 입력하지 않고, 마우스로 아이콘이나 메뉴를 선택하여 모든 작업을 수행하는 방식 : 초보자도 쉽게 사용할 수 있게 GUI채용
#### 선점형 멀티태스킹
- 동시에 여러 개의 프로그램을 실행하면서 운영체제가 각 직업의 CPU이용 시간을 제어하여 응용프로그램 실행 중 문제가 발생하면 해당 프로그램을 강제 종료시키고 모든 시스템 자원을 반환하는 방식 -> 하나의 응용프로그램이 CPU를 독점하는 것을 방지할 수 있어 시스템 다운 현상없이 더욱 안정적인 작업을 할 수 있음

#### PnP(자동 감지기능)
- 컴퓨터 시스템에 프린터나 사운드 카드 등의 하드웨어를 설치했을 때, 해당 하드웨어를 사용하는 데 필요한 시스템 환경을 OS가 자동으로 구성해주는 기능 -> 운영체제가 하드웨어의 규격을 자동으로 인식하여 동작하게 해주므로 PC주변장치를 연결하 때 사용자가 직접 환경을 설정하지 않아도 됨, PnP기능을 활용하기 위해서는 하드웨어와 소프트웨어 모두 PnP를 지원해야 함

#### OLE
- 다른 여러 응용프로그램에서 작성된 문자나 그림 등의 개체를 현재 작성 중인 문서에 자유롭게 연결하거나 삽입 하여 편집할 수 있게 하는 기능 -> OLE로 연결된 이미지를 원본 프로그램에서 수정하거나 편집하면 그 내용이 그대로 해당 문서에 반영됨

#### 255자의 긴 파일명
- VFAT(virtual File Allocation table)를 이용해 최대 255자까지 파일 이름 지정 가능 -> 파일 이름으로는 \/:*?"<>|를 제외한 모든 문자 및 공백을 사용할 수 있으며, 한글의 경우 127자 까지 저장 가능
#### 개인 사용자 시스템
- 컴퓨터한대를 한사람만이 독점해서 사용

## 6. UNIX의 개요 및 특징 ★★
- 소스가 공개된 개방형 시스템
- 시분할 시스템을 위해 설계된 대화식 운영체제
- 다중 작업 지원
- 다중 사용자 지원
- 대부분 C언어로 작성되어 있어 이식성이 높으며 장치 ,프로세스간의 호환성이 높음
- 계층 구조의 파일 시스템
<br>_대다시이계_

-> 하드웨어 > 커널 > 쉘 > 유틸리티 > 사용자

#### 커널
- UNIX의 가장 핵심적인 부분
- 컴퓨터가 부팅될 때 주기억장치에 적재된 후 상주하면서 실행됨
- 하드웨어를 보호하고, 프로그램과 하드웨어 간의 인터페이스 역할을 담당
- 프로세스관리, 기억장치 관리, 파일 관리, 입 출력관리등 여러기능 수행

#### 쉘
- 사용자의 명령어를 인식하여 프로그램을 호출하고, 명령을 수행하는 명령어 해석기
- 주기억장치에 상주하지 않고, 명령어가 포함된 파일 형태로 존재하며 보조 기억장치에서 교체 처리가 가능
- 시스템과 사용자 간의 인터페이스 역할을 담당
- 파이프라인 기능, 지원 및 입, 출력 재지정을 통해 입 출력의 방향 변경 가능
- 여러 종류의 쉘이 있음
- DOS의 COMMAND.COM과 같은 기능 수행

## 7. UNIX에서의 프로세스 간 통신
- 각 프로세스는 시스템 호출을 통해 커널의 기능을 사용하며, 프로세스간 통신은 시그널,파이프,소켓 사용
#### 시그널
- 간단한 메시지를 이용하여 통신하는 것, 초기 UNIX 시스템에서 사용
#### 파이프
- 한 프로세스의 출력이 다른 프로세스의 입력으로 사용되는 단방향 통신 방식
#### 소켓
- 프로세스 사이의 대화를 가능하게 하는 쌍방향 통신 방식

## 8. LINUX의 개요 및 특징
- 1991년 리누스 토발즈가 UNIX를 기반으로 개발한 운영체제
- 대부분의 특징이 UNIX와 동일하며 UNIX와 완벽하게 호환됨
- 프로그램 소스코드가 무료로 공개되어 있음

## 9. MacOS의 개요 및 특징
- 1980년대 Apple사가 UNIX를 기반으로 개발한 운영체제
- 아이맥과 맥북 등 애플 사에서 생산하는 제품에서만 사용가능
- 드라이버 설치 및 install과 unintall의 과정이 단순

---
# 기억장치 관리
## 1. 기억장치의 관리 전략의 개요
- 보조기억장치의 프로그램이나 데이터를 주기억장치에 적재시키는 시기, 적재 위치 등을 지정하여 한정된 주기억장치의 공간을 효율적으로 사용하기 위함
- 반입, 배치, 할당, 교체

## 2. 반입 전략
- 보조기억장체에 보관중인 프로그램이나 데이터를 언제 주기억장치로 적재할 것인지를 경정하는 전략

#### 요구 반입
- 실행중인 프로그램이 특정 프로그램이나 데이터 등의 참조를 요구할 때 적재하는 방법
#### 예상 반입
- 실행중인 프로그램에 의해 참조될 프로그램이나 데이터를 미리 예상하여 적재하는 방법


## 3. 배치 전략
- 새로 반입되는 프로그램이나 데이터를 주기억장치의 어디에 위치 시킬 것인지를 결정하는 전략
#### 최초 적합
- 빈 영역 중에서 단편화를 가장 작게 남기는 분할 영역에 배치
#### 최적 적합
- 빈 영역중에서 단편화를 가장 작게 남기는 분할 영역에 배치
#### 최악 적합
- 빈 영역 중에서 단편화를 가장 많이 남기는 분할 영역에 배치

## 4. 교체 전략
- 이미 사용되고 있는 영역 중에서 어느 영역을 교체 할지 결정하는 전략
## 5. 주기억장치 할당의 개념
- 프로그램이나 데이터를 실행시키기 위해 주기억장치에 어떻게 할당할지 정함
#### 연속 할당 기법: 프로그램을 주기억장치에 연속으로 할당하는 기법
- 단일 분할 할당 기법: 오버레이, 스와핑
- 다중 분할 할당 기법: 고정 분할 할당 기법, 가변 분할 할당 기법

#### 분산 할당 기법: 프로그램을 특정단위의 조각으로 나누어 할당하는 기법
- 페이징 기법
- 세그먼테이션 기법

## 6. 가상기억장치의 개요
- 보조기억장치의 일부를 주기억장치처럼 사용하는 것으로 , 용량이 작은 주기억 장치를 마치 큰 용량을 가진 것처럼 사용하는 기법
- 주기억장치의 용량보다 큰 프로그램을 실행하기 위해 사용
- 주기억장치의 이용률과 다중 프로그래밍 효율을 높일 수 있음
- 가상기억장치에 저장된 프로그램을 실행하려면 가상기억장치의 주소를 주기억장치의 주소로 바꾸는 주소 변환 작업 필요
- 블록 단위로 나누어 사용하므로 연속 할당 방식의 단편화 해결가능

## 7. 페이징 기법
- 가상기억장치에 보관되어 있는 프로그램과 주기억장치의 영역을 동일한 크기로 나눈 후 나눠진 프로그램을 동일하게 나눠진 주기억장치의 영역에 적재시켜 실행하는 기법
- 일정한 크기로 나눈 단위를 페이지라 하고, 페이지 크기로 일정하게 나누어진 주기억장치의 단위를 페이지 프레임 이라 함
- 외부 단편화는 발생하지 않으나, 내부 단편화 발생
- 주소 변환을 위해 페이지의 위치 정보를 갖고 있는 페이지 맵 테이블필요 -> 페이지 맵 테이블 사용으로 비용 증가, 처리 속도 감소

## 8. 세그먼테이션 기법
- 가상기억장치에 보관되어 있는 프로그램을 다양한 크기의 노릴적인 단위로 나눈 후 주기억장치에 적재시켜 기억공간을 절약하기 위해서 사용하는 실행시키는 방법
- 논리적인 크기로 나눈 단위를 세그먼트라고 하며, 각 세그먼트는 고유한 이름과 크기를 가짐
- 기억장치의 사용자 관점을 보존하는 기억장치 관리 기법
- 주소 변환을 위해서 세그먼트가 존재하는 위치 정보를 갖고 있는 세그먼트 맵 테이블 필요
- 세그먼트가 주기억장치에 적재될 때 다른 세그먼트에게 할당된 영역을 침범할 수 없으며, 이를 위해 기억장치 보호키가 필요
- 내부 단편화는 발생하지 않으나, 외부 단편화 발생

## 8. 페이지 교체 알고리즘
#### FIFO
- 각 페이지가 주기억장치에 적재될 때 마다 그때의 시간을 기억시켜 가장 먼저 들어와서 가장 오래 있었던 페이지를 교체하는 기법
#### LRU
- 최근에 가장 오랫동안 사용하지 않은 페이지를 교체하는 기법
- 가장 오래 전에 사용된 페이지 교체
#### LFU
- 사용빈도가 가장 적은 페이지를 교체하는 기법

#### OPT
- 앞으로 가장 오랫동안 사용하지 않을 페이지를 교체하는 기법
- 벨레이디가 제안한 것으로, 페이지 부재 횟수가 가장 적게 발생하는 가장 효율적인 알고리즘

#### NUR
- LRU와 비슷한 알고리즘으로, 최근에 사용하지 않은 페이지를 교체하는 기법
- 각 페이지마다 두개으 ㅣ비트, 즉 참조 비트와 변형 비트 사용

#### SCR
- 가장 오랫동안 주기억 장치에 있던 페이지 중 자주 사용되는 페이지의 교체를 방지하기위한 것으로, FIFO 기법의 단점을 보완하는 기법

## 9. 페이지 크기
#### 페이지 크기가 작을 경우
- 페이지 단편화가 감소되고, 한개의 페이지를 주기억장치로 이동하는 시간이 줄어듬
- 불필요한 내용이 주기억장치에 적재될 확률이 적으므로 효율적인 워킹 셋 유지 가능
- Locality에 더 일치할 수 있기 때문에 기억 장치 효율 높아짐
- 페이지 정보를 갖는 페이지 맵 테이블의 크기가 커지고, 매핑 속도가 늦어짐
- 디스크 접근 횟수가 많아져서 전체적인 입 출력 시간은 늘어남

## 10. Locality
- 프로세스가 실행되는 동안 주기억장치를 참조할 때 일부 페이지만 집중적으로 참조하는 성질이 있다는 이론
- 스래싱을 방지하기 위한 워킹 셋 이론의 기반
- 데닝 교수에 의해 구역성의 개념이 증명됐으면, 캐시 메모리 시스템의 이론적 근거

![image](https://user-images.githubusercontent.com/65350890/108624263-398ed100-7487-11eb-90ed-6ac798c76b66.png)

## 11. 워킹 셋
- 프로세스가 일정 시간 동안 자주 참조하는 페이지들의 집합
- 주기억장치에 상주시킴으로써 페이지 부재 및 페이지 교체 현상이 줄어들어 프로세스의 기억장치 사용이 안정됨
- 시간이 지남에 따라 자주 참조하는 페이지들의 집합이 변화하기 때문에 워킹 셋은 시간에 따라 변경됨

## 12. 페이지 부재 빈도 방식
- 페이지 부재율에 따라 주기억장체에 있는 페이지 프레임의 수를 늘리거나 줄여 페이지 부재율을 적정수준으로 유지하는 방식
- 페이지 부재는 프로세스 실행 시 참조할 페이지가 주기억장치에 없는 현상이며, 페이지 부재 빈도는 페이지 부재가 일어나는 횟수를 의미함

## 13. 프리페이징
- 처음의 과도한 페이지 부재를 방지하기 위해 필요할 것 같은 모든 페이지를 미리 한꺼번에 페이지 프레임에 적재하는 기법 -> 기억장치에 들어온 페이지들 중에서 사용되지 않는 페이지가 많을 수도 있음

## 14. 스래싱
- 프로세스의 처리 시간보다 페이지 교체에 소요되는 시간이 더 많아지는 현상 -> 전체 시스템 성능 저하
- 다중 프로그래밍(멀티 태스킹)의 정도가 높아짐에 따라 CPU의 이용률은 어느 특정 시점 까지는 높아지지만, 다중 프로그래밍의 정도가 더욱 커지면 스래싱이 나타나고, cPU의 이용률은 급격히 감소됨

#### 스래싱 현상 방지방법
- 다중 프로그래밍의 정도를 적정 수준을오 유지
- 페이지 부재 빈도를 조절해 사용
- 워킹 셋을 유지함
- 부족한 자원을 증설하고, 일부 프로세스를 중단시킴